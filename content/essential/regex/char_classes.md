# 字符类

如果您浏览 [Pattern](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html)类规范，您将看到总结支持的正则表达式构造的表。在“字符类”部分，您将找到以下内容：

| 构造 | 描述
|----------
| `[abc]`          | a、b 或 c（简单类） 
| `[^abc]`         | 任何字符，除了 a、b 或 c（否定） 
| `[a-zA-Z]`       | a 到 z 或 A 到 Z，两头的字母包括在内（范围） 
| `[a-d[m-p]]`     | a 到 d 或 m 到 p：[a-dm-p]（并集） 
| `[a-z&&[def]]`     | d、e 或 f（交集） 
| `[a-z&&[^bc]]`     |  a 到 z，除了 b 和 c：[ad-z]（减去） 
| `[a-z&&[^m-p]]`    | a 到 z，而非 m 到 p：[a-lq-z]（减去） 

左侧列指定正则表达式构造，右侧列描述了每个构造将匹配的条件。

注意：这里的xx类并不是指 .class类，在正则表达式的上下文中，字符类是包含在方括号内的一组字符。 **它指定将从给定输入字符串成功匹配单个字符的字符。**

## 简单类

字符类的最基本形式是简单地将一组字符并排放置在方括号内。例如，正则表达式 `[bcr]at`将匹配单词“bat”，“cat”或“rat”，因为它定义了一个字符类（接受“b”，“c”或“r”）作为其第一个字符。
```java
---- Test code ----
regexTest("[bcr]at", "bat");
regexTest("[bcr]at", "cat");
regexTest("[bcr]at", "rat");
        
---- Output ----
我发现文本中的 "bat" 在开始索引 0 和 结束索引 3.
我发现文本中的 "cat" 在开始索引 0 和 结束索引 3.
我发现文本中的 "rat" 在开始索引 0 和 结束索引 3.
        
```
在上面的示例中，只有当第一个字母与字符类定义的一个字符匹配时，整体匹配才会成功

## 范围

有时，您将需要定义一个包含一系列值的字符类，例如字母“a到h”或数字“1到5”。要指定范围，只需在-要匹配的第一个和最后一个字符之间插入“-”元字符，例如[1-5]或[a-h]。您也可以在课堂内将不同的范围相互放在一起，以进一步扩大测试的可能性。例如，[a-zA-Z]将匹配字母表中的任何字母：a到z（小写）或A到Z（大写）。

这里是一些范围和否定范围的列子

```java
---- Test code ----
regexTest("[a-c]", "a");
regexTest("[a-c]", "b");
regexTest("[a-c]", "c");
regexTest("foo[1-5]", "foo1");
regexTest("foo[1-5]", "foo5");
regexTest("foo[1-5]", "foo6");
// 不在范围内
regexTest("foo[^1-5]", "foo1");
regexTest("foo[^1-5]", "foo6");

---- Output ----
我发现文本中的 "a" 在开始索引 0 和 结束索引 1.
我发现文本中的 "b" 在开始索引 0 和 结束索引 1.
我发现文本中的 "c" 在开始索引 0 和 结束索引 1.
我发现文本中的 "foo1" 在开始索引 0 和 结束索引 4.
我发现文本中的 "foo5" 在开始索引 0 和 结束索引 4.
No match found.
No match found.
我发现文本中的 "foo6" 在开始索引 0 和 结束索引 4.

```

## 联合

您还可以使用联合创建由两个或多个单独的字符类组成的单个字符类。要创建一个联合，只需将一个类嵌套在另一个类中，例如`[0-4[6-8]]`。这个特殊联合创建一个匹配数字0,1,2,3,4,6,7和8的单个字符类。

```java
---- Test code ----
regexTest("[0-4 [6-8]]", "0");
regexTest("[0-4 [6-8]]", "5");
regexTest("[0-4 [6-8]]", "6");
regexTest("[0-4 [6-8]]", "8");
regexTest("[0-4 [6-8]]", "9");

---- Output ----
我发现文本中的 "0" 在开始索引 0 和 结束索引 1.
No match found.
我发现文本中的 "6" 在开始索引 0 和 结束索引 1.
我发现文本中的 "8" 在开始索引 0 和 结束索引 1.
No match found.
```

## 交集
要创建一个字符类匹配仅适用于所有的嵌套类，使用的字符`&&`，如`[0-9&&[345]]`。这个特殊的交集创建一个仅匹配两个字符类别共享的数字的单个字符类：3,4和5。 

交集：两个字符类，如`[0-9&&[345]]`，必须是0-9 并且 值为3、4、5 中的一个

```java
---- Test code ----
regexTest("[0-9 && [345]]", "3");
regexTest("[0-9 && [345]]", "4");
regexTest("[0-9 && [345]]", "5");
regexTest("[0-9 && [345]]", "2");
regexTest("[0-9 && [345]]", "6");
regexTest("[0-4 && [345]]", "04");

---- Output ----
我发现文本中的 "3" 在开始索引 0 和 结束索引 1.
我发现文本中的 "4" 在开始索引 0 和 结束索引 1.
我发现文本中的 "5" 在开始索引 0 和 结束索引 1.
No match found.
No match found.
我发现文本中的 "4" 在开始索引 1 和 结束索引 2.
```

这里是一个示例，显示两个范围的交集：
```java
---- Test code ----
regexTest("[2-8 && [4-6]]", "3");
regexTest("[2-8 && [4-6]]", "4");
regexTest("[2-8 && [4-6]]", "5");
regexTest("[2-8 && [4-6]]", "6");
regexTest("[2-8 && [4-6]]", "7");

---- Output ----
No match found.
我发现文本中的 "4" 在开始索引 0 和 结束索引 1.
我发现文本中的 "5" 在开始索引 0 和 结束索引 1.
我发现文本中的 "6" 在开始索引 0 和 结束索引 1.
No match found.
```