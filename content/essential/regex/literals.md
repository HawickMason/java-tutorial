# 字符串文字

此API支持最基本的模式匹配形式是字符串文字的匹配。例如，如果正则表达式是 `foo` 输入字符串 `foo`,匹配将成功，因为字符串是相同的。试用此功能(在前面的测试类中测试):
```bash
我发现文本中的 "foo" 在开始索引 0 和 结束索引 3.
```

这次匹配是成功的，请注意，虽然输入字符串的长度为3个字符，但是起始索引是0，按照惯例是含头不含尾

![](/assets/essential/regex/正则表达式-字符串.png)
字符串中的每个字符都驻留在其自己的单元格中，索引位置指向每个单元格之间。字符串“foo”从索引0开始，以索引3结尾，即使字符本身只占用单元格0,1,2。

随后的测试，你会注意到一些重叠; 下一个匹配的起始索引与前一个匹配的结束索引相同：

```java
regexTest("foo", "foofoofoo");
```
```bash
我发现文本中的 "foo" 在开始索引 0 和 结束索引 3.
我发现文本中的 "foo" 在开始索引 3 和 结束索引 6.
我发现文本中的 "foo" 在开始索引 6 和 结束索引 9.
```

## 元字符

该API还支持一些影响模式匹配方式的特殊字符。将正则表达式更改为`cat.`输入字符串cats。输出将显示如下：
```java
regexTest("cat.", "cats");
```
```bash
我发现文本中的 "cats" 在开始索引 0 和 结束索引 4.
```

匹配仍然成功，即使.输入字符串中不存在点“.”。它成功，因为点是一个元字符 - 具有特殊意义的字符由匹配器解释。元字符“.”。意思是“任何角色”，这就是为什么在这个例子中成功的原因。

该API支持的元字符是： <([{\^-=$!|]})?*+.>

**注意：**  在某些情况下，上面列出的特殊字符不会被视为元字符。**当您了解更多关于如何构造正则表达式时，您将遇到这种情况。但是，您可以使用此列表来检查特定字符是否将被视为元字符。例如， @和#不具有特殊的意义。**

有两种方法来强迫元字符被视为普通字符：

1. 在元字符之前使用反斜杠，或
2. 将其包围\Q（开始报价）和\E（结束它）。  ---？ 这个我没有看明白是个啥

当使用这种技术时，\Q并且\E可以放置在表达内的任何位置，前提是\Q第一。