# 传统文件I/O代码
## 与旧版代码的互操作性
在Java SE 7发布之前，`java.io.File`该类是用于文件I / O的机制，但它有几个缺点。

* 许多方法在失败时没有抛出异常，因此无法获取有用的错误消息。例如，如果文件删除失败，程序将收到“删除失败”，但是不知道是不是因为该文件不存在，该用户没有权限或还有一些其他问题。
* 该rename方法在平台之间不能一致。
* 没有真正的支持符号链接。
* 需要对元数据的更多支持，例如文件权限，文件所有者和其他安全属性。
* 访问文件元数据效率低下。
* 许多File方法没有扩展。通过服务器请求大的目录列表可能导致挂起。大型目录也可能导致内存资源问题，导致拒绝服务。
* 不可能编写可靠的代码，可以递归地走一个文件树，如果有循环的符号链接，那么应该适当地做出回应。

也许你有遗留代码，使用`java.io.File`并希望利用这些功能，对`java.nio.file.Path`代码影响最小。

`java.io.File`类提供的 `toPath`方法，该方法旧式转换`File`实例的`java.nio.file.Path`实例，如下所示：
```java
Path input = file.toPath();
```

然后，您可以利用课程中可用的丰富功能集Path。

例如，假设您有一些删除文件的代码：
```java
file.delete();
```

您可以修改此代码以使用该`Files.delete`方法，如下所示：
```java
Path fp = file.toPath();
Files.delete（fp）;
```
相反，该 `Path.toFile`方法构造一个`java.io.File`对象的Path对象。


## 将java.io.File函数映射到java.nio.file